\section{Analysis of Alternatives (Fabio)}
\subsection{Front End}
In order to establish what alternatives we have to create our design, we first need to clearly define what is the domain of our system. Firstly, the hardware this system to be is going to used on is a underwater microscope used to capture the environmental conditions of the specimens to be studied \textit{in situ}, or on site. This microscope has two cameras, a left and a right camera used to later generate a stereoscopic image of the captured media. The microscope also has 4 on board sensors, temperature, pH, pressure and dissolved oxygen sensors used to capture the environmental conditions under the water. The microscope has a total of 8 buttons that serve as the only way to interact with the device under the water and a 800x480 resolution display as its view into the real time operating system, Raspberry Pi OS.\\
Now that the domain has been clearly established we can now discuss what alternatives we have at our disposal to create a user interface. There are 3 main ways to create a user interface on a computer:
\begin{enumerate}
	\item In the web browser or web based.
	\item A Native application.
	\item Using electron or React native, i.e Native Browser.
\end{enumerate}
Each one of these design alternatives have their advantages and disadvantages individually, but, in order to properly analyze their potential advantages and disadvantages, we first have to put it in the context of what the M.O.S.I.S microscope is.\\
At its core, the M.O.S.I.S microscope is a Raspberry Pi microcontroller with sensors and cameras attached to it that runs off a battery. Given that the Raspberry Pi is a single core, 1.8GHz ARM processor with 4GB of system memory using an SD Card for booting the Raspberry Pi OS which is a Debian Linux distribution specifically designed for use on the Raspberry Pi microcontroller.\cite{ltdRaspberryPiModel}\cite{DebianUniversalOperating} Given the hardware that the system-to-be is going to be running on is, in term of computing resources, weak, we could easily eliminate both web based and native browser alternatives right then and there since web browsers are large pieces of software that do not run particularly well on limited hardware. The web based architecture also has problems with accessing low level aspects of the operating system and hardware easily with little overhead. This is due to the fact that a web browser is a completely sandboxed environment for code execution, meaning that a web based implementation would need to establish a client and server relationship to access hardware directly via the server. A web based implementation also suffers from being not particularly efficient in terms of CPU cycles and memory usage due to the sandboxed nature and having much more features than what is needed for our design. By extension, a native browser implementation would suffer a lot of the same drawbacks as a purely web based application. A native browser implementation is closer to the hardware since a native client is compiled to the target hardware and a web like environment is spawned inside the client. This kind of implementation accelerates deployment on many platforms, such as Discord that has clients for Windows, Mac, IOS, Android, Linux and the browser only using a single main code base.\cite{Discord2023} This advantage is of no benefit to this project since the M.O.S.I.S microscope is a purpose built piece of hardware with a lot of software already written specifically for it and thus portability is not of any use in this case. A native browser implementation also suffers from being resource intensive, especially in the memory department, where a single instance of an application uses hundreds of megabytes of memory for a single application.\\
This leads us then to create a native application, but this then poses an interesting question, how do we make a native application? There are a plethora of options to use, .NET from Microsoft, Qt and GTK from Linux, or even newer libraries such as Iced from Rust and many more. In order to narrow down which alternatives work in our case, we again have to look at our domain. The Raspberry Pi peripheral access library is the only officially supported way to interact with the on board peripherals on the Raspberry Pi. The Raspberry Pi library only officially supports the Python programming language. There are wrappers or bindings for the Pi's library functions in other languages such as Rust, but they are not officially supported by the vendors of the Pi. Therefore, we are restricted to building our system in the Python programming language.\\
Now that we have defined our domain and chosen programming language, now we have the task of selecting which UI library (or none) to use. Let us get of the way the option of not using a UI library up front. Given that by the end of the semester we have to give a prototype based on our design, allocating a large portion of our allotted development time into creating just the markup of the UI without the help of a library would be not only inadvisable but also delay the project to the point that on time delivery would be impossible. Creating a new UI framework between a team of two in less than 3 months is simply impossible.\\
There are plenty of options of UI library bindings for Python: TKinter, PyQt, PyGTK, Kivy, PySimpleGUI and WxPython just to name a few. We can safely discard TKinter immediately because the current UI for the M.O.S.I.S microscope is written in TKinter and has a myriad of issues such as being undocumented, antiquated, buggy and slow. WxPython are binding for Python for the popular wxWidgets library in C++. It is well liked among developers of proprietary software since its ``modified version of LGPL explicitly allowing not distributing the sources of an application using the library even in the case of static linking.``\cite{WxWidgetsWxWidgets2023} However, due to the teams objections to having such a restrictive license, we have decided to not use wxWidgets. PySimpleGUI would be a valid option but, it only serves to simplify tools such as TKinter, Qt and WxPython and is not a UI library onto its own. Plus it is relatively new, from 2018, thus it is not as established as other alternatives in the UI library landscape. Kivy is purely written in Python and is meant to be portable, for use in mobile applications. Due to concerns over performance of the Python programming language the team opted not to use Kivy. This now leads to the big two in the Linux ecosystem Qt and GTK with their associated Python bindings PyQt and PyGTK respectively.\\
GTK was initially released on April 14, 1998 and is the UI library used in all GNOME desktop applications and GNOME is the flagship desktop environment for the most widely used Linux distribution, Ubuntu.\cite{GNOME2023}\cite{Ubuntu2023} It is licensed under the GPL and currently is on version 4.10 and is still actively maintained. QT was released May 20, 1995 and is the UI library used in all KDE applications.\cite{QtSoftware2023} Most famously, KDE Plasma is the desktop environment used in the wildly successful Steam Deck.\cite{SteamDeck2023} Qt is licensed under LGPL, GPL and Qt Commercial Licenses.\cite{QtLicensingQt} Both of the UI libraries meet our requirements of being open source and established, thus the argument now comes down to developer experience.\\
GTK is an opinionated library, meaning that the GTK developers place heavy emphasis on having all GTK applications having a smaller look and feel. This is all well and good when making a consistent desktop environment in Linux but forces a certain design language across a wide range of applications. This would not be too much of a problem if it would be simple and straight forward to override the default styling and behaviors of the widgets that the GTK library offers, but alas it is not simple. Overriding a simple button in GTK quickly devolves into several dozen lines of boilerplate code just to change the label of a button. Never mind doing this overriding on several dozen widgets, which quickly degrades the quality of the code base and reduces readability of the source code.\\
Qt allows for the individual widgets to have a customized style sheet, with CSS like syntax, in order to achieve the look and feel as desired. Qt also has much simpler syntax than GTK which allows for more rapid prototyping. Qt also provides Qt designer, a tool that allows the creation of user interface mark up in a graphical interface. This is in stark contrast to GTK where the developer has to manually create the markup using XML. GTK is also criticized for having an unstable development cycle where there are major changes to the library rather frequently where as Qt has a much more stable development cycle. Given all this analysis we chose PyQt to be our UI library of choice going forward in this project.\\
\subsection{Database}
Now for the database, databases come in two main flavors, relational and non-relational databases. The M.O.S.I.S microscope only captures four fields, temperature, pH, pressure and dissolved oxygen using its onboard sensors, four field for camera configuration, two fields for study configuration, the time a metadata entry was captured and two fields for absolute paths for the captured media. This gives us a total thirteen total fields to be captured related by a simple entry identifier. As a team, we realized that given the simple relationship  between the recorded fields, a relational database was the best choice given our use case.\\
As for what relational database engine to use, that requires to again look at the microscope's hardware limitations and project objectives. The Raspberry Pi only has 4GB of system memory and a single CPU core running at 1.8GHz, running off a battery, in an environment without internet that can quickly destroy the hardware. Most databases utilize a server to communicate with the database. MySQL, PostgreSQL, Microsoft SQL server, and MongoDB all utilize this client server relationship. This style of database works great for concurrent applications where hundreds if not thousands of requests to and from the database are made every second. The backup of these kinds of databases rely on frequently mirroring the database on an off site backup. However, both of these advantages are null and void in our use case since the microscope will be in an environment without internet until the data is off loaded, utilized by users that do not know how to perform a database backup and that the hardware that the database is being hosted on is limited, meaning that both disk space, CPU usage and memory use are major concerns. This leads us to a database engine called SQLite, a single threaded, synchronous relational database that stores itself in a file. It is the de facto standard in embedded, desktop and smartphone applications where a more sophisticated database alternative is unfeasible or impractical. As mentioned it stores itself in a file, making it simple to backup the database. It has four types for all data: text, integer, real and blob, meaning that the database engine can compile and compress the data much more efficiently. The single threaded nature of SQLite also lends it self well to the Raspberry Pi to conserve computing resources. As the name suggests SQLite uses SQL syntax meaning that any future maintainers of this project need not learn an exotic database query language to interact with it. Given how well SQLite meets the requirements for out use case we have chosen it to be our database going forward.
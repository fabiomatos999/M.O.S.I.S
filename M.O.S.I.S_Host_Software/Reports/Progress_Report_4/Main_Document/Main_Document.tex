\documentclass[12pt]{article}

\usepackage{graphicx}

\begin{document}
\include{Title_Page/Title_Page}
\section*{Executive Summary}
\tableofcontents
\section{Introduction}
The Marine Operated Stereoscopic Imaging System (M.O.S.I.S) is a device created by David M. Repollet Otero along with Manuel A. Jimenez Cedeno in order to study marine life \textit{in situ} in stereoscopic vision while capturing environmental conditions such as temperature, pH, pressure and dissolved oxygen. As of November 27, 2023, the microscope itself has a fully completed user interface capable of capturing various kinds of still photography and videos. However, at its core, the M.O.S.I.S microscope is an embedded system running a Raspberry Pi 4b, meaning that processing speed and memory are both severely limited. But not only is processing power limited, but the device itself will be deployed in an extremely hostile environment, where the microscope can be destroyed at a moments notice. Even more so, the microscope does not provide the means to recover the captured data nor does it provide the means to analyses and present the data to the user. The host software for the M.O.S.I.S microscope aims to backup the data captured by the M.O.S.I.S microscope, analyses the data captured by the microscope and generate reports based on the captured data.\\
\subsection{System Requirements}
\subsubsection{Domain Requirements}
\begin{itemize}
	\item The system-to-be must allow the backup of the M.O.S.I.S project Raspberry Pi's operating system.
	\item The system-to-be must allow the backup of the images captured by the M.O.S.I.S microscope Raspberry Pi.
	\item The system-to-be must have a database that stores the media captured by the M.O.S.I.S microscope Raspberry Pi.
	\item The system-to-be must have a database that stores the sensor data captured by the M.O.S.I.S microscope Raspberry Pi.
	\item The system-to-be must create a stereoscopic image from the media captured by the M.O.S.I.S microscope Raspberry Pi.
	\item The system-to-be must have the means to pre-configured the type of media capture before deployment in the field.
	\item The system-to-be must tag the media captured the M.O.S.I.S Raspberry Pi with the information stored in the database.
	\item The system-to-be must analyze the captured media for bleaching estimates.
	\item The system-to-be must create reports from the captured media.
\end{itemize}
\subsubsection{Interface Requirements}
\begin{itemize}
	\item The system-to-be's database must contain image information that includes:
	      \begin{itemize}
		      \item Left Camera Image
		      \item Right Camera Image
		      \item Stereoscopic Image
		      \item Left Threshold Image
		      \item Right Threshold Image
		      \item Time Stamp
		      \item Temperature
		      \item Ph
		      \item Pressure
		      \item Dissolved Oxygen (DO) Content
	      \end{itemize}
	\item The system-to-be must have a home page where there is a preview of all images currently within the database.
	\item The system-to-be must create an individual page for each entry within the database.
\end{itemize}
This report is organized in the following parts:
\begin{enumerate}
	\item Introduction
	\item Design Criteria and Design Specifications
	\item Methods and approach to the solution
	\item Market overview
	\item Results, and impact of the project
	\item Conclusions and Future Work
	\item Bibliographic References
	\item Appendix
\end{enumerate}
\section{Design Criteria and Specifications}
\subsection{System Specifications}
\begin{itemize}
	\item Backs up M.O.S.I.S microscope media data via SSH
	\item Generates stereoscopic images or video from left and right cameras.
	\item Tags stereoscopic media with the sensor data and time stamp associated with that entry.
	\item Generate threshold images from captured media.
	\item Allows searching by ID, shot type, illumination type and date.
	\item Exports either whole database or searched media entries to a PDF report.
	\item Creates compressed backups of M.O.S.I.S microscope operating system.
	\item Officially supports Windows and Linux operating systems.
\end{itemize}
\subsection{Design Criteria}
The main design criterion for the host software was to create a set of user friendly utilities that:
\begin{itemize}
	\item Abstracts and automates the process of interacting with the M.O.S.I.S microscope as much as possible.
	\item Is usable by marine biologist end users.
	\item Is reliable enough to backup and analyze the data from the M.O.S.I.S microscope for the lifetime of the device
	\item Is free and open source.
\end{itemize}
These design criteria are in part due to the target users of the M.O.S.I.S microscope, those being, marine biologist researchers. These researchers know how to analyze the captured data and to draw conclusions from said data, but most of them lack the expertise to use complex computer software, especially ones designed for computer scientists and engineers. Thus, with these design criterion in mind, the host software design process was applied in the following ways:
\begin{enumerate}
	\item Minimize interaction with the command line as much as possible.
	\item Automate the installation of dependencies as much as possible.
	\item Web browser based.
	\item Streamline the process of backing up the captured media and microscope operating system.
	\item Friendly and modern user interface design.
	\item Automate the process of data analysis.
	\item Streamline the process of data export.
	\item Seamless integration between the host machine and the Raspberry Pi.
\end{enumerate}
\subsection{Analysis of alternatives}
Given that the term ``host software'' and the design criteria are rather broad, this gives us a lot of possible and viable alternatives for a design. To start we need to first identify what are the possible ways of creating a user interface for this piece of software. There are 3 main approaches used in modern software design for making user interfaces:
\begin{enumerate}
	\item Command Line Interface (CLI)
	\item Terminal User Interface (TUI)
	\item Graphical User Interface (GUI)
\end{enumerate}
Both the command line and terminal interfaces utilize a terminal to display information and interact with the user but in distinct ways. CLI applications use command line parameters within a terminal to have differing functionality within the application and most require very little interaction from the user. A TUI application also runs within a terminal but are more akin to GUI applications where graphics and text are shown to the user and they can navigate through the application and require user integration like most GUI applications. Graphical user interfaces are traditional and modern way of interaction with software, where images, text, video, and various forms of multimedia are displayed to the user within a native interface or a web browser. Given that the end users for the host software are marine biology researchers, they are not accustomed to use the terminal as a means of using their computer, thus we can discard both command line and terminal user interfaces and chose a to make a Graphical User Interface.\\
Given that we are making a graphical user interface application, this now begs the question, what alternatives do we have at our disposal to make a graphical user interface? In modern software development, there are 3 main paradigms to create a GUI application:
\begin{enumerate}
	\item Web based
	\item Native
	\item ``Web-Native''
\end{enumerate}
Web based applications utilize the web browser to serve as the basis for the application. These kinds of applications have a client-server relationship where the client is the web browser that displays the user interface and the server is the software the handles the back end logic and processes and stores data and runs on native hardware and not in the web browser. On the other hand native applications have a monolithic architecture wherein a singular unit of software displays the user interface and handles the back end logic. ``Web-Native'' applications are a hybrid approach to native and web based applications where the application it self runs on native hardware but leverages web technologies such as electron and React-Native to utilize the client server relationship to more easily port applications to various platforms.\\
On the surface all 3 architectures are viable for the host software, but there are additional considerations outside of the user requirements and design criteria, namely portability and maintainability. Since the M.O.S.I.S microscope, at it's core is a Raspberry Pi 4 micro-controller, it utilizes the official Raspberry Pi OS which is based off of Debian Linux which is a free and open source UNIX operating system. Given how well UNIX operating systems work together, the initial goal was to make the host software exclusive to Ubuntu/Debian. However, the client wanted the host software to be on Microsoft Windows, so as a compromise, making the host software portable between Linux and Windows was a major design consideration from the start. Second is maintainability, given that the M.O.S.I.S project's software functions are multi semester collaborative effort between various undergraduate engineering students, the existing code base for the M.O.S.I.S microscope are written in Python for the microscope functions and C for the sensor hub. Given that C is a compiled, lower level programming language than Python and that Python itself the most popular programming language in the world, it was decided that Python would the programming language of choice for the host software. Python has a readily available interpreter on almost every operating system and architecture, thus making it portable. Python is, as mentioned previously, the most popular programming language in the world, where finding people that can maintain, update and fix the host application is easier, thus making it maintainable. However, Python on its own does not answer the fundamental question of which graphical user interface paradigm to use for our design, to answer that we have to analyze each paradigm on its own with the design criterion.\\
Web based applications, as the name implies, are applications that run in a web browser such as Chromium or Firefox. These kinds of applications are extremely portable since all popular operating systems and CPU architectures have a web browser written for them. They are also very since the client-server relationship and routing allows for segments of an application to be sand-boxed from each other. Native applications are typically more efficient with system resources than web based applications but typically more difficult to maintain due to the monolithic architecture of a native application and how every GUI library works. Native applications have to also be ported to either be ported to other platforms or use a GUI library that is cross platform, thus making it not as portable. ``Web-Native'', in this use case, suffer from the disadvantages of both native and Web based applications, where since they are developed for a specific architecture they are not as portable and since they use more specialized frameworks such as electron or React-Native finding people to maintain this software would prove to be much more difficult, making it less maintainable. This leads use to choose Web based, GUI, Python application for the host software.
\section{Methods and approach to the solution}
\section{Results, and impact of the project}
\section{Conclusions and Future Work}
\bibliographystyle{IEEEtranN}
\addcontentsline{toc}{section}{Bibliographic References}
\bibliography{../../../../References_Library/ICOM5047}
\appendix
\section{Glossary}
\section{User Requirements}
\section{System Specifications}
\section{Analysis of Alternatives}
\section{System Architecture and Interfaces}
\section{Design Documentation}
\section{Testing Plan}
\section{Task Progress and Gantt Chart}
\end{document}